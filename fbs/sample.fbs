namespace fbs;

// This should probably be generated by some python file as we template on
// state/input/outut size

// available types are:
// 8 bit: byte ubyte bool
// 16 bit: short ushort
// 32 bit: int uint float
// 64 bit: long ulong double

struct State {
    x0:double;
    x1:double;
    x2:double;
    x3:double;
}

struct Input {
    u0:double;
    u1:double;
}

struct Output {
    y0:double;
    y1:double;
}

struct SecondOrderMatrix {
    m00:double;
    m01:double;
    m10:double;
    m11:double;
}


// m, n (2, 4) matrix
struct LqrGainMatrix {
    k00:double;
    k01:double;
    k02:double;
    k03:double;
    k10:double;
    k11:double;
    k12:double;
    k13:double;
}

// n, l (4, 2) matrix
struct KalmanGainMatrix {
    k00:double;
    k01:double;
    k10:double;
    k11:double;
    k20:double;
    k21:double;
    k30:double;
    k31:double;
}

struct SymmetricStateMatrix {
    q00:double;
    q01:double;
    q02:double;
    q03:double;
    q11:double;
    q12:double;
    q13:double;
    q22:double;
    q23:double;
    q33:double;
}

struct SymmetricInputMatrix {
    r00:double;
    r01:double;
    r11:double;
}

struct SymmetricOutputMatrix {
    r00:double;
    r01:double;
    r11:double;
}

table Kalman {
    state_estimate:State;
    error_covariance:SymmetricStateMatrix;
    process_noise_covariance:SymmetricStateMatrix;
    measurement_noise_covariance:SymmetricOutputMatrix;
    kalman_gain:KalmanGainMatrix;
}

table Lqr {
    horizon:uint;
    state_target:State;
    state_cost:SymmetricStateMatrix;
    input_cost:SymmetricInputMatrix;
    horizon_cost:SymmetricStateMatrix;
    lqr_gain:LqrGainMatrix;
}

table Bicycle {
    v:double;
    dt:double;
    M:SecondOrderMatrix;
    C1:SecondOrderMatrix;
    K0:SecondOrderMatrix;
    K2:SecondOrderMatrix;
}

table Sample {
    timestamp:uint;
    bicycle:Bicycle;
    bicycle_state:State; // true state
    bicycle_input:Input; // applied input
    bicycle_output:Output; // output without noise
    bicycle_measurement:Output; // output with noise
    lqr:Lqr;
    kalman:Kalman;
}

table SampleLog {
    samples:[Sample];
}

root_type SampleLog;
