namespace fbs;

// This should probably be generated by some python file as we template on
// state/input/outut size

// available types are:
// 8 bit: byte ubyte bool
// 16 bit: short ushort
// 32 bit: int uint float
// 64 bit: long ulong double

struct State {
    x0:double;
    x1:double;
    x2:double;
    x3:double;
}

struct Input {
    u0:double;
    u1:double;
}

struct Output {
    y0:double;
    y1:double;
}

struct SecondOrderMatrix {
    m00:double;
    m01:double;
    m10:double;
    m11:double;
}


// m, n (2, 4) matrix
struct LqrGainMatrix {
    k00:double;
    k01:double;
    k02:double;
    k03:double;
    k10:double;
    k11:double;
    k12:double;
    k13:double;
}

// n, l (4, 2) matrix
struct KalmanGainMatrix {
    k00:double;
    k01:double;
    k10:double;
    k11:double;
    k20:double;
    k21:double;
    k30:double;
    k31:double;
}

// n, n (4, 4) matrix
struct StateMatrix {
    a00:double;
    a01:double;
    a02:double;
    a03:double;
    a10:double;
    a11:double;
    a12:double;
    a13:double;
    a20:double;
    a21:double;
    a22:double;
    a23:double;
    a30:double;
    a31:double;
    a32:double;
    a33:double;
}

// n, m (4, 2) matrix
struct InputMatrix {
    b00:double;
    b01:double;
    b10:double;
    b11:double;
    b20:double;
    b21:double;
    b30:double;
    b31:double;
}

// l, n (2, 4) matrix
struct OutputMatrix {
    c00:double;
    c01:double;
    c02:double;
    c03:double;
    c10:double;
    c11:double;
    c12:double;
    c13:double;
}

// l, l (2, 2) matrix
struct FeedthroughMatrix {
    d00:double;
    d01:double;
    d10:double;
    d11:double;
}

// n, n (4, 4) symmetric matrix
struct SymmetricStateMatrix {
    q00:double;
    q01:double;
    q02:double;
    q03:double;
    q11:double;
    q12:double;
    q13:double;
    q22:double;
    q23:double;
    q33:double;
}

// m, m (2, 2) symmetric matrix
struct SymmetricInputMatrix {
    r00:double;
    r01:double;
    r11:double;
}

// l, l (2, 2) symmetric matrix
struct SymmetricOutputMatrix {
    r00:double;
    r01:double;
    r11:double;
}

table Kalman {
    state_estimate:State;
    error_covariance:SymmetricStateMatrix;
    process_noise_covariance:SymmetricStateMatrix;
    measurement_noise_covariance:SymmetricOutputMatrix;
    kalman_gain:KalmanGainMatrix;
}

table Lqr {
    horizon:uint;
    state_target:State;
    state_cost:SymmetricStateMatrix;
    input_cost:SymmetricInputMatrix;
    horizon_cost:SymmetricStateMatrix;
    lqr_gain:LqrGainMatrix;
}

table Bicycle {
    v:double;
    dt:double;
    M:SecondOrderMatrix;
    C1:SecondOrderMatrix;
    K0:SecondOrderMatrix;
    K2:SecondOrderMatrix;
    Ad:StateMatrix;
    Bd:InputMatrix;
    Cd:OutputMatrix;
    Dd:FeedthroughMatrix;
}

table Sample {
    timestamp:uint;
    bicycle:Bicycle;
    kalman:Kalman;
    lqr:Lqr;
    state:State; // true state
    input:Input; // applied input
    output:Output; // output without noise
    measurement:Output; // output with noise
}

root_type Sample;
