// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_SAMPLE_FBS_H_
#define FLATBUFFERS_GENERATED_SAMPLE_FBS_H_

#include "flatbuffers/flatbuffers.h"


namespace fbs {

struct State;
struct Input;
struct Output;
struct SecondOrderMatrix;
struct LqrGainMatrix;
struct KalmanGainMatrix;
struct SymmetricStateMatrix;
struct SymmetricInputMatrix;
struct SymmetricOutputMatrix;
struct Kalman;
struct Lqr;
struct Bicycle;
struct Sample;
struct SampleLog;

MANUALLY_ALIGNED_STRUCT(8) State FLATBUFFERS_FINAL_CLASS {
 private:
  double x0_;
  double x1_;
  double x2_;
  double x3_;

 public:
  State(double x0, double x1, double x2, double x3)
    : x0_(flatbuffers::EndianScalar(x0)), x1_(flatbuffers::EndianScalar(x1)), x2_(flatbuffers::EndianScalar(x2)), x3_(flatbuffers::EndianScalar(x3)) { }

  double x0() const { return flatbuffers::EndianScalar(x0_); }
  double x1() const { return flatbuffers::EndianScalar(x1_); }
  double x2() const { return flatbuffers::EndianScalar(x2_); }
  double x3() const { return flatbuffers::EndianScalar(x3_); }
};
STRUCT_END(State, 32);

MANUALLY_ALIGNED_STRUCT(8) Input FLATBUFFERS_FINAL_CLASS {
 private:
  double u0_;
  double u1_;

 public:
  Input(double u0, double u1)
    : u0_(flatbuffers::EndianScalar(u0)), u1_(flatbuffers::EndianScalar(u1)) { }

  double u0() const { return flatbuffers::EndianScalar(u0_); }
  double u1() const { return flatbuffers::EndianScalar(u1_); }
};
STRUCT_END(Input, 16);

MANUALLY_ALIGNED_STRUCT(8) Output FLATBUFFERS_FINAL_CLASS {
 private:
  double y0_;
  double y1_;

 public:
  Output(double y0, double y1)
    : y0_(flatbuffers::EndianScalar(y0)), y1_(flatbuffers::EndianScalar(y1)) { }

  double y0() const { return flatbuffers::EndianScalar(y0_); }
  double y1() const { return flatbuffers::EndianScalar(y1_); }
};
STRUCT_END(Output, 16);

MANUALLY_ALIGNED_STRUCT(8) SecondOrderMatrix FLATBUFFERS_FINAL_CLASS {
 private:
  double m00_;
  double m01_;
  double m10_;
  double m11_;

 public:
  SecondOrderMatrix(double m00, double m01, double m10, double m11)
    : m00_(flatbuffers::EndianScalar(m00)), m01_(flatbuffers::EndianScalar(m01)), m10_(flatbuffers::EndianScalar(m10)), m11_(flatbuffers::EndianScalar(m11)) { }

  double m00() const { return flatbuffers::EndianScalar(m00_); }
  double m01() const { return flatbuffers::EndianScalar(m01_); }
  double m10() const { return flatbuffers::EndianScalar(m10_); }
  double m11() const { return flatbuffers::EndianScalar(m11_); }
};
STRUCT_END(SecondOrderMatrix, 32);

MANUALLY_ALIGNED_STRUCT(8) LqrGainMatrix FLATBUFFERS_FINAL_CLASS {
 private:
  double k00_;
  double k01_;
  double k02_;
  double k03_;
  double k10_;
  double k11_;
  double k12_;
  double k13_;

 public:
  LqrGainMatrix(double k00, double k01, double k02, double k03, double k10, double k11, double k12, double k13)
    : k00_(flatbuffers::EndianScalar(k00)), k01_(flatbuffers::EndianScalar(k01)), k02_(flatbuffers::EndianScalar(k02)), k03_(flatbuffers::EndianScalar(k03)), k10_(flatbuffers::EndianScalar(k10)), k11_(flatbuffers::EndianScalar(k11)), k12_(flatbuffers::EndianScalar(k12)), k13_(flatbuffers::EndianScalar(k13)) { }

  double k00() const { return flatbuffers::EndianScalar(k00_); }
  double k01() const { return flatbuffers::EndianScalar(k01_); }
  double k02() const { return flatbuffers::EndianScalar(k02_); }
  double k03() const { return flatbuffers::EndianScalar(k03_); }
  double k10() const { return flatbuffers::EndianScalar(k10_); }
  double k11() const { return flatbuffers::EndianScalar(k11_); }
  double k12() const { return flatbuffers::EndianScalar(k12_); }
  double k13() const { return flatbuffers::EndianScalar(k13_); }
};
STRUCT_END(LqrGainMatrix, 64);

MANUALLY_ALIGNED_STRUCT(8) KalmanGainMatrix FLATBUFFERS_FINAL_CLASS {
 private:
  double k00_;
  double k01_;
  double k10_;
  double k11_;
  double k20_;
  double k21_;
  double k30_;
  double k31_;

 public:
  KalmanGainMatrix(double k00, double k01, double k10, double k11, double k20, double k21, double k30, double k31)
    : k00_(flatbuffers::EndianScalar(k00)), k01_(flatbuffers::EndianScalar(k01)), k10_(flatbuffers::EndianScalar(k10)), k11_(flatbuffers::EndianScalar(k11)), k20_(flatbuffers::EndianScalar(k20)), k21_(flatbuffers::EndianScalar(k21)), k30_(flatbuffers::EndianScalar(k30)), k31_(flatbuffers::EndianScalar(k31)) { }

  double k00() const { return flatbuffers::EndianScalar(k00_); }
  double k01() const { return flatbuffers::EndianScalar(k01_); }
  double k10() const { return flatbuffers::EndianScalar(k10_); }
  double k11() const { return flatbuffers::EndianScalar(k11_); }
  double k20() const { return flatbuffers::EndianScalar(k20_); }
  double k21() const { return flatbuffers::EndianScalar(k21_); }
  double k30() const { return flatbuffers::EndianScalar(k30_); }
  double k31() const { return flatbuffers::EndianScalar(k31_); }
};
STRUCT_END(KalmanGainMatrix, 64);

MANUALLY_ALIGNED_STRUCT(8) SymmetricStateMatrix FLATBUFFERS_FINAL_CLASS {
 private:
  double q00_;
  double q01_;
  double q02_;
  double q03_;
  double q11_;
  double q12_;
  double q13_;
  double q22_;
  double q23_;
  double q33_;

 public:
  SymmetricStateMatrix(double q00, double q01, double q02, double q03, double q11, double q12, double q13, double q22, double q23, double q33)
    : q00_(flatbuffers::EndianScalar(q00)), q01_(flatbuffers::EndianScalar(q01)), q02_(flatbuffers::EndianScalar(q02)), q03_(flatbuffers::EndianScalar(q03)), q11_(flatbuffers::EndianScalar(q11)), q12_(flatbuffers::EndianScalar(q12)), q13_(flatbuffers::EndianScalar(q13)), q22_(flatbuffers::EndianScalar(q22)), q23_(flatbuffers::EndianScalar(q23)), q33_(flatbuffers::EndianScalar(q33)) { }

  double q00() const { return flatbuffers::EndianScalar(q00_); }
  double q01() const { return flatbuffers::EndianScalar(q01_); }
  double q02() const { return flatbuffers::EndianScalar(q02_); }
  double q03() const { return flatbuffers::EndianScalar(q03_); }
  double q11() const { return flatbuffers::EndianScalar(q11_); }
  double q12() const { return flatbuffers::EndianScalar(q12_); }
  double q13() const { return flatbuffers::EndianScalar(q13_); }
  double q22() const { return flatbuffers::EndianScalar(q22_); }
  double q23() const { return flatbuffers::EndianScalar(q23_); }
  double q33() const { return flatbuffers::EndianScalar(q33_); }
};
STRUCT_END(SymmetricStateMatrix, 80);

MANUALLY_ALIGNED_STRUCT(8) SymmetricInputMatrix FLATBUFFERS_FINAL_CLASS {
 private:
  double r00_;
  double r01_;
  double r11_;

 public:
  SymmetricInputMatrix(double r00, double r01, double r11)
    : r00_(flatbuffers::EndianScalar(r00)), r01_(flatbuffers::EndianScalar(r01)), r11_(flatbuffers::EndianScalar(r11)) { }

  double r00() const { return flatbuffers::EndianScalar(r00_); }
  double r01() const { return flatbuffers::EndianScalar(r01_); }
  double r11() const { return flatbuffers::EndianScalar(r11_); }
};
STRUCT_END(SymmetricInputMatrix, 24);

MANUALLY_ALIGNED_STRUCT(8) SymmetricOutputMatrix FLATBUFFERS_FINAL_CLASS {
 private:
  double r00_;
  double r01_;
  double r11_;

 public:
  SymmetricOutputMatrix(double r00, double r01, double r11)
    : r00_(flatbuffers::EndianScalar(r00)), r01_(flatbuffers::EndianScalar(r01)), r11_(flatbuffers::EndianScalar(r11)) { }

  double r00() const { return flatbuffers::EndianScalar(r00_); }
  double r01() const { return flatbuffers::EndianScalar(r01_); }
  double r11() const { return flatbuffers::EndianScalar(r11_); }
};
STRUCT_END(SymmetricOutputMatrix, 24);

struct Kalman FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const State *state_estimate() const { return GetStruct<const State *>(4); }
  const SymmetricStateMatrix *error_covariance() const { return GetStruct<const SymmetricStateMatrix *>(6); }
  const SymmetricStateMatrix *process_noise_covariance() const { return GetStruct<const SymmetricStateMatrix *>(8); }
  const SymmetricOutputMatrix *measurement_noise_covariance() const { return GetStruct<const SymmetricOutputMatrix *>(10); }
  const KalmanGainMatrix *kalman_gain() const { return GetStruct<const KalmanGainMatrix *>(12); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<State>(verifier, 4 /* state_estimate */) &&
           VerifyField<SymmetricStateMatrix>(verifier, 6 /* error_covariance */) &&
           VerifyField<SymmetricStateMatrix>(verifier, 8 /* process_noise_covariance */) &&
           VerifyField<SymmetricOutputMatrix>(verifier, 10 /* measurement_noise_covariance */) &&
           VerifyField<KalmanGainMatrix>(verifier, 12 /* kalman_gain */) &&
           verifier.EndTable();
  }
};

struct KalmanBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_state_estimate(const State *state_estimate) { fbb_.AddStruct(4, state_estimate); }
  void add_error_covariance(const SymmetricStateMatrix *error_covariance) { fbb_.AddStruct(6, error_covariance); }
  void add_process_noise_covariance(const SymmetricStateMatrix *process_noise_covariance) { fbb_.AddStruct(8, process_noise_covariance); }
  void add_measurement_noise_covariance(const SymmetricOutputMatrix *measurement_noise_covariance) { fbb_.AddStruct(10, measurement_noise_covariance); }
  void add_kalman_gain(const KalmanGainMatrix *kalman_gain) { fbb_.AddStruct(12, kalman_gain); }
  KalmanBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  KalmanBuilder &operator=(const KalmanBuilder &);
  flatbuffers::Offset<Kalman> Finish() {
    auto o = flatbuffers::Offset<Kalman>(fbb_.EndTable(start_, 5));
    return o;
  }
};

inline flatbuffers::Offset<Kalman> CreateKalman(flatbuffers::FlatBufferBuilder &_fbb,
   const State *state_estimate = 0,
   const SymmetricStateMatrix *error_covariance = 0,
   const SymmetricStateMatrix *process_noise_covariance = 0,
   const SymmetricOutputMatrix *measurement_noise_covariance = 0,
   const KalmanGainMatrix *kalman_gain = 0) {
  KalmanBuilder builder_(_fbb);
  builder_.add_kalman_gain(kalman_gain);
  builder_.add_measurement_noise_covariance(measurement_noise_covariance);
  builder_.add_process_noise_covariance(process_noise_covariance);
  builder_.add_error_covariance(error_covariance);
  builder_.add_state_estimate(state_estimate);
  return builder_.Finish();
}

struct Lqr FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  uint32_t horizon() const { return GetField<uint32_t>(4, 0); }
  const State *state_target() const { return GetStruct<const State *>(6); }
  const SymmetricStateMatrix *state_cost() const { return GetStruct<const SymmetricStateMatrix *>(8); }
  const SymmetricInputMatrix *input_cost() const { return GetStruct<const SymmetricInputMatrix *>(10); }
  const SymmetricStateMatrix *horizon_cost() const { return GetStruct<const SymmetricStateMatrix *>(12); }
  const LqrGainMatrix *lqr_gain() const { return GetStruct<const LqrGainMatrix *>(14); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, 4 /* horizon */) &&
           VerifyField<State>(verifier, 6 /* state_target */) &&
           VerifyField<SymmetricStateMatrix>(verifier, 8 /* state_cost */) &&
           VerifyField<SymmetricInputMatrix>(verifier, 10 /* input_cost */) &&
           VerifyField<SymmetricStateMatrix>(verifier, 12 /* horizon_cost */) &&
           VerifyField<LqrGainMatrix>(verifier, 14 /* lqr_gain */) &&
           verifier.EndTable();
  }
};

struct LqrBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_horizon(uint32_t horizon) { fbb_.AddElement<uint32_t>(4, horizon, 0); }
  void add_state_target(const State *state_target) { fbb_.AddStruct(6, state_target); }
  void add_state_cost(const SymmetricStateMatrix *state_cost) { fbb_.AddStruct(8, state_cost); }
  void add_input_cost(const SymmetricInputMatrix *input_cost) { fbb_.AddStruct(10, input_cost); }
  void add_horizon_cost(const SymmetricStateMatrix *horizon_cost) { fbb_.AddStruct(12, horizon_cost); }
  void add_lqr_gain(const LqrGainMatrix *lqr_gain) { fbb_.AddStruct(14, lqr_gain); }
  LqrBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  LqrBuilder &operator=(const LqrBuilder &);
  flatbuffers::Offset<Lqr> Finish() {
    auto o = flatbuffers::Offset<Lqr>(fbb_.EndTable(start_, 6));
    return o;
  }
};

inline flatbuffers::Offset<Lqr> CreateLqr(flatbuffers::FlatBufferBuilder &_fbb,
   uint32_t horizon = 0,
   const State *state_target = 0,
   const SymmetricStateMatrix *state_cost = 0,
   const SymmetricInputMatrix *input_cost = 0,
   const SymmetricStateMatrix *horizon_cost = 0,
   const LqrGainMatrix *lqr_gain = 0) {
  LqrBuilder builder_(_fbb);
  builder_.add_lqr_gain(lqr_gain);
  builder_.add_horizon_cost(horizon_cost);
  builder_.add_input_cost(input_cost);
  builder_.add_state_cost(state_cost);
  builder_.add_state_target(state_target);
  builder_.add_horizon(horizon);
  return builder_.Finish();
}

struct Bicycle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  double v() const { return GetField<double>(4, 0); }
  double dt() const { return GetField<double>(6, 0); }
  const SecondOrderMatrix *M() const { return GetStruct<const SecondOrderMatrix *>(8); }
  const SecondOrderMatrix *C1() const { return GetStruct<const SecondOrderMatrix *>(10); }
  const SecondOrderMatrix *K0() const { return GetStruct<const SecondOrderMatrix *>(12); }
  const SecondOrderMatrix *K2() const { return GetStruct<const SecondOrderMatrix *>(14); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, 4 /* v */) &&
           VerifyField<double>(verifier, 6 /* dt */) &&
           VerifyField<SecondOrderMatrix>(verifier, 8 /* M */) &&
           VerifyField<SecondOrderMatrix>(verifier, 10 /* C1 */) &&
           VerifyField<SecondOrderMatrix>(verifier, 12 /* K0 */) &&
           VerifyField<SecondOrderMatrix>(verifier, 14 /* K2 */) &&
           verifier.EndTable();
  }
};

struct BicycleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_v(double v) { fbb_.AddElement<double>(4, v, 0); }
  void add_dt(double dt) { fbb_.AddElement<double>(6, dt, 0); }
  void add_M(const SecondOrderMatrix *M) { fbb_.AddStruct(8, M); }
  void add_C1(const SecondOrderMatrix *C1) { fbb_.AddStruct(10, C1); }
  void add_K0(const SecondOrderMatrix *K0) { fbb_.AddStruct(12, K0); }
  void add_K2(const SecondOrderMatrix *K2) { fbb_.AddStruct(14, K2); }
  BicycleBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  BicycleBuilder &operator=(const BicycleBuilder &);
  flatbuffers::Offset<Bicycle> Finish() {
    auto o = flatbuffers::Offset<Bicycle>(fbb_.EndTable(start_, 6));
    return o;
  }
};

inline flatbuffers::Offset<Bicycle> CreateBicycle(flatbuffers::FlatBufferBuilder &_fbb,
   double v = 0,
   double dt = 0,
   const SecondOrderMatrix *M = 0,
   const SecondOrderMatrix *C1 = 0,
   const SecondOrderMatrix *K0 = 0,
   const SecondOrderMatrix *K2 = 0) {
  BicycleBuilder builder_(_fbb);
  builder_.add_dt(dt);
  builder_.add_v(v);
  builder_.add_K2(K2);
  builder_.add_K0(K0);
  builder_.add_C1(C1);
  builder_.add_M(M);
  return builder_.Finish();
}

struct Sample FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  uint32_t timestamp() const { return GetField<uint32_t>(4, 0); }
  const Bicycle *bicycle() const { return GetPointer<const Bicycle *>(6); }
  const Kalman *kalman() const { return GetPointer<const Kalman *>(8); }
  const Lqr *lqr() const { return GetPointer<const Lqr *>(10); }
  const State *state() const { return GetStruct<const State *>(12); }
  const Input *input() const { return GetStruct<const Input *>(14); }
  const Output *output() const { return GetStruct<const Output *>(16); }
  const Output *measurement() const { return GetStruct<const Output *>(18); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, 4 /* timestamp */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* bicycle */) &&
           verifier.VerifyTable(bicycle()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 8 /* kalman */) &&
           verifier.VerifyTable(kalman()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 10 /* lqr */) &&
           verifier.VerifyTable(lqr()) &&
           VerifyField<State>(verifier, 12 /* state */) &&
           VerifyField<Input>(verifier, 14 /* input */) &&
           VerifyField<Output>(verifier, 16 /* output */) &&
           VerifyField<Output>(verifier, 18 /* measurement */) &&
           verifier.EndTable();
  }
};

struct SampleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(uint32_t timestamp) { fbb_.AddElement<uint32_t>(4, timestamp, 0); }
  void add_bicycle(flatbuffers::Offset<Bicycle> bicycle) { fbb_.AddOffset(6, bicycle); }
  void add_kalman(flatbuffers::Offset<Kalman> kalman) { fbb_.AddOffset(8, kalman); }
  void add_lqr(flatbuffers::Offset<Lqr> lqr) { fbb_.AddOffset(10, lqr); }
  void add_state(const State *state) { fbb_.AddStruct(12, state); }
  void add_input(const Input *input) { fbb_.AddStruct(14, input); }
  void add_output(const Output *output) { fbb_.AddStruct(16, output); }
  void add_measurement(const Output *measurement) { fbb_.AddStruct(18, measurement); }
  SampleBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SampleBuilder &operator=(const SampleBuilder &);
  flatbuffers::Offset<Sample> Finish() {
    auto o = flatbuffers::Offset<Sample>(fbb_.EndTable(start_, 8));
    return o;
  }
};

inline flatbuffers::Offset<Sample> CreateSample(flatbuffers::FlatBufferBuilder &_fbb,
   uint32_t timestamp = 0,
   flatbuffers::Offset<Bicycle> bicycle = 0,
   flatbuffers::Offset<Kalman> kalman = 0,
   flatbuffers::Offset<Lqr> lqr = 0,
   const State *state = 0,
   const Input *input = 0,
   const Output *output = 0,
   const Output *measurement = 0) {
  SampleBuilder builder_(_fbb);
  builder_.add_measurement(measurement);
  builder_.add_output(output);
  builder_.add_input(input);
  builder_.add_state(state);
  builder_.add_lqr(lqr);
  builder_.add_kalman(kalman);
  builder_.add_bicycle(bicycle);
  builder_.add_timestamp(timestamp);
  return builder_.Finish();
}

struct SampleLog FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::Vector<flatbuffers::Offset<Sample>> *samples() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Sample>> *>(4); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* samples */) &&
           verifier.Verify(samples()) &&
           verifier.VerifyVectorOfTables(samples()) &&
           verifier.EndTable();
  }
};

struct SampleLogBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_samples(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Sample>>> samples) { fbb_.AddOffset(4, samples); }
  SampleLogBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SampleLogBuilder &operator=(const SampleLogBuilder &);
  flatbuffers::Offset<SampleLog> Finish() {
    auto o = flatbuffers::Offset<SampleLog>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<SampleLog> CreateSampleLog(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Sample>>> samples = 0) {
  SampleLogBuilder builder_(_fbb);
  builder_.add_samples(samples);
  return builder_.Finish();
}

inline const SampleLog *GetSampleLog(const void *buf) { return flatbuffers::GetRoot<SampleLog>(buf); }

inline bool VerifySampleLogBuffer(flatbuffers::Verifier &verifier) { return verifier.VerifyBuffer<SampleLog>(); }

inline const char *SampleLogIdentifier() { return "BICY"; }

inline bool SampleLogBufferHasIdentifier(const void *buf) { return flatbuffers::BufferHasIdentifier(buf, SampleLogIdentifier()); }

inline void FinishSampleLogBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<SampleLog> root) { fbb.Finish(root, SampleLogIdentifier()); }

}  // namespace fbs

#endif  // FLATBUFFERS_GENERATED_SAMPLE_FBS_H_
